<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creative Digital Alchemy Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Custom slider styles for better visibility */
        .slider::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #8b5cf6; cursor: pointer; transition: background 0.15s ease-in-out; }
        .slider::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #8b5cf6; cursor: pointer; }

        /* Canvas Stacking and Styling */
        canvas { background-color: #1f2937; border-radius: 0.75rem; display: block; } 
        
        #canvas-stack { 
            position: relative; 
            margin: 0 auto; /* Center the stack, size is set in JS */
        }
        
        /* Ensure both canvases are absolutely positioned for perfect overlap */
        #canvas-stack canvas {
            position: absolute; 
            top: 0; 
            left: 0;
        }

        #canvas-container { max-width: 100%; height: auto; display: flex; justify-content: center; align-items: center; }


        /* UI Notification */
        .ui-notification { position: fixed; bottom: -50px; left: 50%; transform: translateX(-50%); padding: 10px 20px; border-radius: 9999px; color: white; opacity: 0; transition: all 0.3s ease-in-out; z-index: 2000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); }
        .ui-notification.success { background-color: #10b981; }
        .ui-notification.warning { background-color: #f59e0b; }
        .ui-notification.error { background-color: #ef4444; }
        .ui-notification.show { bottom: 20px; opacity: 1; }
        
        /* Button styles */
        .btn-primary { @apply flex items-center justify-center space-x-1 px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-lg hover:bg-purple-700 transition duration-150 disabled:bg-gray-500 disabled:shadow-none; }
        .btn-secondary { @apply flex items-center justify-center space-x-1 px-3 py-1.5 bg-gray-700 text-gray-200 font-medium text-sm rounded-lg hover:bg-gray-600 transition duration-150 disabled:opacity-50; }
        
        /* Custom cursor for inpainting */
        .cursor-pen { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><circle cx='16' cy='16' r='14' stroke='%23fff' stroke-width='2' fill='none' /></svg>") 16 16, crosshair; }
        
        /* Modal Styles */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #1f2937;
            padding: 2rem;
            border-radius: 1rem;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-extrabold text-purple-400">Creative Digital Alchemy Studio</h1>
            <p class="text-gray-400 mt-2">Generate and edit high-fidelity images with advanced control using the **Gemini-2.5-Flash-Image-Preview** model.</p>
        </header>

        <!-- Optimized Layout Grid: Canvas (L) and Controls (R) -->
        <main class="grid grid-cols-1 lg:grid-cols-5 gap-6">

            <!-- LEFT PANEL: CANVAS & HISTORY (Takes 3/5 width on desktop) -->
            <div id="left-panel" class="lg:col-span-3 space-y-6">
                
                <!-- Canvas Container -->
                <div id="canvas-container" class="relative bg-gray-800 p-2 rounded-xl shadow-inner shadow-gray-700/50 flex justify-center items-center overflow-auto min-h-[300px] max-h-[800px]">
                    
                    <!-- Stack Container for Canvases -->
                    <div id="canvas-stack" style="position: relative;"> 
                        <canvas id="editor-canvas" class="rounded-lg"></canvas>
                        <canvas id="mask-canvas" class="rounded-lg hidden"></canvas>
                    </div>

                    <!-- Loading Overlay -->
                    <div id="loading-overlay" class="absolute inset-0 bg-gray-900/95 flex flex-col justify-center items-center text-white p-4 rounded-xl hidden">
                        <svg class="animate-spin h-10 w-10 text-purple-400 mb-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <p class="text-lg font-semibold text-gray-300"></p>
                        <small class="text-gray-500 mt-2">Generating high-fidelity results...</small>
                    </div>
                </div>
                
                <!-- History and Export Actions -->
                <div class="flex flex-wrap gap-3 justify-between">
                    <div class="flex space-x-3">
                        <button id="import-btn" class="btn-secondary">
                            <i data-feather="upload" class="w-4 h-4"></i><span>Import Image</span>
                        </button>
                        <input type="file" id="file-input" accept="image/*" class="hidden">

                        <button id="undo-btn" class="btn-secondary" disabled>
                            <i data-feather="rotate-ccw" class="w-4 h-4"></i><span>Undo</span>
                        </button>
                        <button id="redo-btn" class="btn-secondary" disabled>
                            <i data-feather="rotate-cw" class="w-4 h-4"></i><span>Redo</span>
                        </button>
                    </div>
                    <button id="export-btn" class="btn-primary" disabled>
                        <i data-feather="download" class="w-4 h-4"></i><span>Export Result</span>
                    </button>
                </div>
            </div>

            <!-- RIGHT PANEL: ALL CONTROLS (Takes 2/5 width on desktop) -->
            <div id="right-panel" class="lg:col-span-2 space-y-4">
                
                <!-- Main Action Button -->
                <button id="apply-diffusion-btn" class="btn-primary w-full text-lg shadow-purple-600/50">
                    <i data-feather="zap" class="w-6 h-6"></i>
                    <span>Start Image Generation</span>
                </button>

                <!-- Prompts -->
                <div class="bg-gray-800 p-5 rounded-xl shadow-2xl border border-gray-700">
                    <h2 class="text-xl font-bold mb-4 text-gray-200 flex items-center space-x-2"><i data-feather="terminal" class="w-5 h-5"></i><span>Alchemy Prompts</span></h2>
                    
                    <div class="flex justify-between items-end mb-1">
                        <label for="diffusion-prompt" class="block text-sm font-medium">Creative Vision (Positive Prompt)</label>
                        <button id="show-guide-btn" class="btn-secondary px-2 py-0.5 !text-xs bg-purple-900 hover:bg-purple-800">
                            <i data-feather="book-open" class="w-3 h-3"></i><span class="ml-1">Prompt Guide</span>
                        </button>
                    </div>
                    <textarea id="diffusion-prompt" rows="3" class="w-full p-2.5 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-purple-500 focus:border-purple-500 transition duration-150" placeholder="A stunning hyper-detailed digital art of..."></textarea>
                    
                    <label for="negative-prompt" class="block text-sm font-medium mt-4 mb-1">Rejection Criteria (Negative Prompt)</label>
                    <textarea id="negative-prompt" rows="2" class="w-full p-2.5 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-purple-500 focus:border-purple-500 transition duration-150" placeholder="blurry, low quality, watermarks, poorly defined"></textarea>
                </div>
                
                <!-- Generation Mode -->
                <div class="bg-gray-800 p-5 rounded-xl shadow-2xl border border-purple-800/50">
                    <h2 class="text-xl font-bold mb-4 text-purple-300 flex items-center space-x-2"><i data-feather="settings" class="w-5 h-5"></i><span>Generation Mode</span></h2>
                    <div class="flex items-center justify-between mb-4">
                        <label for="pure-generation-mode" class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="pure-generation-mode" class="form-checkbox h-5 w-5 text-purple-600 rounded-full border-gray-600 bg-gray-700 focus:ring-purple-500 transition duration-150">
                            <span class="text-sm font-medium">Pure Generation (Text-to-Image)</span>
                        </label>
                    </div>
                    <div class="text-xs text-gray-500">
                        <p class="mb-1">When checked, ignores the canvas image. For Image-to-Image and Inpainting, uncheck this box.</p>
                    </div>
                </div>

                <!-- Deep Transformation (Image-to-Image Sliders) -->
                <div id="image-to-image-controls" class="bg-gray-800 p-5 rounded-xl shadow-2xl border border-gray-700">
                    <h2 class="text-xl font-bold mb-4 text-gray-200 flex items-center space-x-2"><i data-feather="droplet" class="w-5 h-5"></i><span>Deep Transformation</span></h2>

                    <!-- Creativity Slider -->
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-1 flex justify-between">
                            <span>Creativity / Fidelity Blend</span>
                            <span id="creativity-val" class="text-purple-400 font-mono">0.5</span>
                        </label>
                        <input type="range" id="creativity-slider" min="0" max="1" value="0.5" step="0.01" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <!-- Strength Slider -->
                    <div class="mb-2">
                        <label class="block text-sm font-medium mb-1 flex justify-between">
                            <span>Transformation Strength</span>
                            <span id="strength-val" class="text-purple-400 font-mono">0.5</span>
                        </label>
                        <input type="range" id="strength-slider" min="0" max="1" value="0.5" step="0.01" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <!-- Inpainting Controls -->
                <div class="bg-gray-800 p-5 rounded-xl shadow-2xl border border-blue-800/50">
                    <h2 class="text-xl font-bold mb-4 text-blue-300 flex items-center space-x-2"><i data-feather="edit-3" class="w-5 h-5"></i><span>Inpainting Mask Tool</span></h2>
                    
                    <button id="toggle-mask-btn" class="btn-primary w-full bg-blue-600 hover:bg-blue-700 mb-4">
                        <i data-feather="tool" class="w-4 h-4"></i>
                        <span>Enable Mask Drawing</span>
                    </button>

                    <div id="mask-controls-panel" class="hidden space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-1 flex justify-between">
                                <span>Brush Size</span>
                                <span id="brush-size-val" class="text-blue-400 font-mono">20</span>
                            </label>
                            <input type="range" id="brush-size-slider" min="5" max="100" value="20" step="5" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <button id="clear-mask-btn" class="btn-secondary w-full bg-red-600 hover:bg-red-700 text-white">
                            <i data-feather="x-circle" class="w-4 h-4"></i>
                            <span>Clear Mask</span>
                        </button>
                    </div>
                    <div class="text-xs text-gray-500 mt-2">
                        <p>Use the mask to highlight areas you want the AI to modify or replace based on your prompt.</p>
                    </div>
                </div>

                <!-- Seed & Fidelity -->
                <div class="bg-gray-800 p-5 rounded-xl shadow-2xl border border-gray-700">
                    <h2 class="text-xl font-bold mb-4 text-gray-200 flex items-center space-x-2"><i data-feather="hash" class="w-5 h-5"></i><span>Advanced Parameters</span></h2>

                    <div class="flex items-center space-x-2 mb-4">
                        <input type="text" id="seed-input" placeholder="Seed (Optional)" class="w-3/4 p-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:ring-purple-500 focus:border-purple-500 transition duration-150">
                        <button id="random-seed-btn" class="btn-secondary w-1/4">
                            <i data-feather="shuffle" class="w-4 h-4"></i>
                            <span class="hidden sm:inline">Random</span>
                        </button>
                    </div>
                    
                    <div class="flex items-center justify-between mb-4">
                        <label for="strict-fidelity-mode" class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="strict-fidelity-mode" class="form-checkbox h-5 w-5 text-purple-600 rounded-md border-gray-600 bg-gray-700 focus:ring-purple-500 transition duration-150">
                            <span class="text-sm font-medium">Strict Fidelity Mode</span>
                        </label>
                    </div>
                </div>

                <!-- Visual Adjustments -->
                <div class="bg-gray-800 p-5 rounded-xl shadow-2xl border border-gray-700">
                    <h2 class="text-xl font-bold mb-4 text-gray-200 flex items-center space-x-2"><i data-feather="sliders" class="w-5 h-5"></i><span>Visual Adjustments</span></h2>
                    
                    <div class="grid grid-cols-1 gap-6">
                        <!-- Brightness -->
                        <div>
                            <label class="block text-sm font-medium mb-1 flex justify-between">
                                <span>Brightness</span>
                                <span id="brightness-val" class="text-purple-400 font-mono">0</span>
                            </label>
                            <input type="range" id="brightness-slider" min="-100" max="100" value="0" step="1" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>

                        <!-- Contrast -->
                        <div>
                            <label class="block text-sm font-medium mb-1 flex justify-between">
                                <span>Contrast</span>
                                <span id="contrast-val" class="text-purple-400 font-mono">0</span>
                            </label>
                            <input type="range" id="contrast-slider" min="-255" max="255" value="0" step="1" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>

                        <!-- Gamma -->
                        <div>
                            <label class="block text-sm font-medium mb-1 flex justify-between">
                                <span>Gamma (Ratio)</span>
                                <span id="gamma-val" class="text-purple-400 font-mono">1.00</span>
                            </label>
                            <input type="range" id="gamma-slider" min="10" max="300" value="100" step="1" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    
                    <button id="apply-filter-btn" class="btn-primary mt-4 w-full" disabled>
                        <i data-feather="save" class="w-4 h-4"></i><span>Save Adjustments to History</span>
                    </button>
                </div>
                
            </div>
            <!-- END RIGHT PANEL -->

        </main>
        <!-- END OPTIMIZED LAYOUT GRID -->
    </div>

    <!-- ADVANCED PROMPT GUIDE MODAL -->
    <div id="prompt-guide-modal" class="modal-overlay hidden">
        <div class="modal-content text-gray-100 w-full lg:w-3/5">
            <h2 class="text-3xl font-bold mb-4 text-purple-400 border-b border-gray-700 pb-2">Advanced Prompt Engineering Guide</h2>
            <p class="text-gray-400 mb-6">Use these techniques to express complex creative ideas with technical and evocative language, maximizing artistic results while staying within content guidelines.</p>
            
            <div class="space-y-6 text-sm">
                <!-- Section 1: Action and Intensity -->
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-semibold text-red-300 mb-2 flex items-center space-x-2"><i data-feather="shield-off" class="w-4 h-4"></i><span>Action, Conflict, & Intensity</span></h3>
                    <p class="mb-2">Avoid: **Violence, blood, gore, killing, dead**. Focus on the *consequence* or *energy*.</p>
                    <ul class="list-disc ml-5 space-y-1">
                        <li>Replace **"Blood"** with: <span class="text-red-400">Crimson flow, ruby highlights, vascular texture, sanguine spray, chromatic separation.</span></li>
                        <li>Replace **"Gore/Mutilation"** with: <span class="text-red-400">Stylized battle damage, shattered ceramic, ripped fabric, high-impact fragmentation.</span></li>
                        <li>Replace **"Killing/Fighting"** with: <span class="text-red-400">High-intensity conflict, decisive moment, dynamic struggle, terminal velocity impact, symbolic defeat.</span></li>
                    </ul>
                </div>

                <!-- Section 2: Human Form and Suggestiveness -->
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-semibold text-pink-300 mb-2 flex items-center space-x-2"><i data-feather="user" class="w-4 h-4"></i><span>The Human Form & Emotion</span></h3>
                    <p class="mb-2">Avoid: **Nude, suggestive, exposed, erotic**. Focus on **Classical Art, Drapery, and Light**.</p>
                    <ul class="list-disc ml-5 space-y-1">
                        <li>Replace **"Nude"** with: <span class="text-pink-400">Classical sculpture, marble form, ethereal silhouette, figure study, anatomically correct sketch.</span></li>
                        <li>Replace **"Revealing"** with: <span class="text-pink-400">Loose drapery, flowing garments, sheer silk, spotlight on the figure, soft focus, dramatic shadows.</span></li>
                        <li>Add terms like: <span class="text-pink-400">Masterpiece of Renaissance era, Baroque painting, Greco-Roman statue, detailed chiaroscuro.</span></li>
                    </ul>
                </div>

                <!-- Section 3: Technical Style Keywords -->
                <div class="bg-gray-700 p-4 rounded-lg">
                    <h3 class="text-xl font-semibold text-green-300 mb-2 flex items-center space-x-2"><i data-feather="code" class="w-4 h-4"></i><span>Technical & Artistic Directives</span></h3>
                    <p class="mb-2">These powerful terms guide the model without triggering content filters.</p>
                    <ul class="list-disc ml-5 space-y-1">
                        <li>**Resolution/Detail:** <span class="text-green-400">8k, UHD, hyperdetailed, meticulously rendered, ZBrush detail, cinematic, photorealistic.</span></li>
                        <li>**Lighting/Mood:** <span class="text-green-400">Volumetric lighting, rim light, god rays, hard light, ambient occlusion, moody twilight, neon glow.</span></li>
                        <li>**Style/Texture:** <span class="text-green-400">Concept art, matte painting, ink wash, pointillism, fractal design, oil on canvas, highly textural.</span></li>
                    </ul>
                </div>
            </div>

            <button id="close-guide-btn" class="btn-primary w-full mt-6 bg-gray-600 hover:bg-gray-700">
                <i data-feather="x" class="w-4 h-4"></i><span>Close Guide</span>
            </button>
        </div>
    </div>
    <!-- END MODAL -->

    <script>
        // Creative Digital Alchemy Studio - Main Application Logic

        // Global State and Constants
     // NEVER store API keys in client-side code!
	// This points to your secure backend
const getCreativeApiUrl = () => 'https://pixelalchemy-backend.onrender.com/generate';

        const IMAGE_MIME_TYPE = 'image/png';
        const MAX_DIMENSION = 768; // Enforce a max dimension for model stability

        let currentImage = null;
        let canvas, ctx, maskCanvas, maskCtx, canvasContainer;
        let creativitySlider, strengthSlider, creativityVal, strengthVal;
        let strictFidelityMode, pureGenerationMode;
        
        // Inpainting state
        let isInpaintingMode = false;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let brushSize = 20;
        let maskDrawn = false; // Flag to check if mask canvas has any drawing

        // History management
        let historyStack = [];
        let historyPointer = -1;
        const MAX_HISTORY = 15;
        let originalImageData = null;

        /**
         * Enhanced notification system for creative experience
         */
        function showUINotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `ui-notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            void notification.offsetWidth;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 5000);
        }

        /**
         * Save current canvas state to history
         */
        function saveState() {
            if (!currentImage) return;

            if (historyPointer < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyPointer + 1);
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            
            const dataUrl = tempCanvas.toDataURL(IMAGE_MIME_TYPE);
            historyStack.push(dataUrl);

            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }

            historyPointer = historyStack.length - 1;
            updateHistoryButtons();
        }

        /**
         * Load state from history
         */
        function loadState(index) {
            if (index < 0 || index >= historyStack.length) return;
            
            // Safety check for active filters
            const currentB = parseInt(document.getElementById('brightness-slider').value);
            const currentC = parseInt(document.getElementById('contrast-slider').value);
            const currentG = parseFloat(document.getElementById('gamma-slider').value) / 100;

            if (currentImage && (currentB !== 0 || currentC !== 0 || currentG !== 1.0)) {
                showUINotification("Applied filters cleared for history traversal.", 'warning');
            }

            historyPointer = index;
            const dataUrl = historyStack[historyPointer];
            
            const img = new Image();
            img.onload = function() {
                canvas.width = img.width;
                canvas.height = img.height;
                maskCanvas.width = img.width; // Also update mask canvas size
                maskCanvas.height = img.height;
                ctx.drawImage(img, 0, 0);

                currentImage = img;
                originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // FIX: Update the canvas stack dimensions when loading from history
                const canvasStack = document.getElementById('canvas-stack');
                canvasStack.style.width = img.width + 'px';
                canvasStack.style.height = img.height + 'px';

                resetFilterSliders();
                clearMask(); // Clear mask when undoing/redoing
                updateHistoryButtons();
                showUINotification(`Loaded creative state ${historyPointer + 1}/${historyStack.length}`);
            };
            img.src = dataUrl;
        }

        /**
         * Update history button states
         */
        function updateHistoryButtons() {
            document.getElementById('undo-btn').disabled = historyPointer <= 0;
            document.getElementById('redo-btn').disabled = historyPointer >= historyStack.length - 1;
            document.getElementById('apply-filter-btn').disabled = !currentImage;
            document.getElementById('export-btn').disabled = !currentImage;
        }

        /**
         * Enhanced image loading with creative capabilities
         */
        function loadImageSourceToCanvas(sourceData, callback) {
            const img = new Image();
            
            img.onload = function() {
                // --- FIX: ENFORCE MAX DIMENSION FOR MODEL STABILITY ---
                let newWidth = img.width;
                let newHeight = img.height;

                if (img.width > MAX_DIMENSION || img.height > MAX_DIMENSION) {
                    const ratio = Math.min(MAX_DIMENSION / img.width, MAX_DIMENSION / img.height);
                    newWidth = img.width * ratio;
                    newHeight = img.height * ratio;
                }
                
                // Round to the nearest integer
                newWidth = Math.round(newWidth);
                newHeight = Math.round(newHeight);
                // --- END FIX ---


                // Set dimensions for both main and mask canvases
                canvas.width = newWidth;
                canvas.height = newHeight;
                maskCanvas.width = newWidth; // Also update mask canvas size
                maskCanvas.height = newHeight;
                
                // FIX: Explicitly set the size of the stacking parent (#canvas-stack)
                const canvasStack = document.getElementById('canvas-stack');
                canvasStack.style.width = newWidth + 'px';
                canvasStack.style.height = newHeight + 'px';
                
                // Redraw image onto the new dimensions
                ctx.drawImage(img, 0, 0, newWidth, newHeight); 
                
                currentImage = img;
                originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Adjust canvas container height based on new image height
                // Note: We leave this to allow the container to fill its space, but the canvas stack controls the inner size
                // canvasContainer.style.height = newHeight + 20 + 'px';

                saveState();
                resetFilterSliders();
                clearMask(); // Clear mask on new image load
                
                if (callback) callback();
            };
            
            img.onerror = function() {
                showUINotification("Failed to load image. Please try another file or prompt.", 'error');
                if (callback) callback();
            };
            
            if (sourceData.startsWith('data:')) {
                img.src = sourceData;
            } else {
                img.src = 'data:' + IMAGE_MIME_TYPE + ';base64,' + sourceData;
            }
        }

        /**
         * Enhanced exponential backoff for creative API calls
         */
        async function exponentialBackoffFetch(url, options, maxRetries = 7) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429) { 
                        throw new Error('429 Rate Limit');
                    }
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error('HTTP error! status: ' + response.status + '. Details: ' + errorText);
                    }
                    return response;
                } catch (error) {
                    if (i < maxRetries - 1 && (error.message.includes('429') || error.message.includes('Failed to fetch'))) {
                        const delay = Math.pow(2, i) * 1000 + Math.random() * 1500;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error;
                    }
                }
            }
            throw new Error('Maximum retries exceeded.');
        }

        /**
         * Loading overlay control
         */
        function showLoading(message = 'Applying Deep Transformation...') {
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.remove('hidden');
            loadingOverlay.querySelector('p').textContent = message;
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        // --- Inpainting Logic Start ---

        function getMousePos(event) {
            const rect = maskCanvas.getBoundingClientRect();
            // Scale mouse coordinates to canvas coordinates
            const scaleX = maskCanvas.width / rect.width;
            const scaleY = maskCanvas.height / rect.height;
            
            // Handle touch events
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function startDrawing(event) {
            if (!isInpaintingMode) return;
            isDrawing = true;
            const pos = getMousePos(event);
            lastX = pos.x;
            lastY = pos.y;
            drawMask(event);
            event.preventDefault(); // Prevent touch scrolling
        }

        function drawMask(event) {
            if (!isDrawing || !isInpaintingMode) return;
            maskDrawn = true; // Set flag
            
            const pos = getMousePos(event);

            // Set drawing style for mask (red with transparency for user visualization)
            maskCtx.lineJoin = 'round';
            maskCtx.lineCap = 'round';
            maskCtx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; 
            maskCtx.lineWidth = brushSize;

            // Perform drawing
            maskCtx.beginPath();
            maskCtx.moveTo(lastX, lastY);
            maskCtx.lineTo(pos.x, pos.y);
            maskCtx.stroke();
            
            lastX = pos.x;
            lastY = pos.y;
            event.preventDefault();
        }

        function stopDrawing() {
            isDrawing = false;
        }
        
        function clearMask() {
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            maskDrawn = false;
            showUINotification('Inpainting mask cleared.', 'warning');
        }

        function toggleInpaintingMode() {
            if (!currentImage) {
                showUINotification('Please import an image first to use the inpainting tool.', 'error');
                return;
            }
            
            isInpaintingMode = !isInpaintingMode;
            const toggleBtn = document.getElementById('toggle-mask-btn');
            const maskPanel = document.getElementById('mask-controls-panel');
            
            if (isInpaintingMode) {
                // Enable Inpainting
                maskCanvas.classList.remove('hidden');
                maskCanvas.classList.add('cursor-pen');
                maskPanel.classList.remove('hidden');
                toggleBtn.textContent = 'Disable Mask Drawing';
                toggleBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                toggleBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
                showUINotification('Inpainting mode enabled. Draw a red mask over the area you want to change.', 'warning');
            } else {
                // Disable Inpainting
                maskCanvas.classList.add('hidden');
                maskCanvas.classList.remove('cursor-pen');
                maskPanel.classList.add('hidden');
                toggleBtn.textContent = 'Enable Mask Drawing';
                toggleBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                toggleBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
                showUINotification('Inpainting mode disabled.', 'success');
            }
        }

        /**
         * Converts the visible mask canvas (red lines) into a binary (white on transparent) PNG mask
         * for the model, where white represents the masked area.
         */
        function getBinaryMaskBase64() {
            // 1. Create a temporary canvas matching the mask size
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = maskCanvas.width;
            tempCanvas.height = maskCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // 2. Get the pixel data from the drawn mask (maskCtx)
            const maskImageData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
            const data = maskImageData.data;

            // 3. Create a new ImageData object for the binary mask
            const whiteMaskData = tempCtx.createImageData(tempCanvas.width, tempCanvas.height);
            const maskPixelData = whiteMaskData.data; // This is the data array for the new white mask

            for (let i = 0; i < data.length; i += 4) {
                // Check if the pixel in the drawn mask has any opacity (i.e., a red line exists)
                if (data[i + 3] > 0) { 
                    // If opaque, set the corresponding pixel in the new mask to WHITE (255, 255, 255) and fully opaque (255)
                    maskPixelData[i] = 255;     // R
                    maskPixelData[i + 1] = 255; // G
                    maskPixelData[i + 2] = 255; // B
                    maskPixelData[i + 3] = 255; // A (Opaque)
                }
                // If transparent (data[i+3] === 0), it remains transparent (0, 0, 0, 0) by default in the new ImageData
            }
            
            // 4. Put the new, binary white mask image data onto the temporary context
            tempCtx.putImageData(whiteMaskData, 0, 0);

            // 5. Return the Base64 representation of the binary mask
            return tempCanvas.toDataURL(IMAGE_MIME_TYPE).split(',')[1];
        }

        // --- Inpainting Logic End ---


        /**
         * Filter application for visual adjustments (Existing)
         */
        function applyFilter(brightness, contrast, gamma) {
            if (!originalImageData) return;

            const imageData = new ImageData(
                new Uint8ClampedArray(originalImageData.data),
                originalImageData.width,
                originalImageData.height
            );
            const data = imageData.data;

            const C = contrast;
            const contrastFactor = (259.0 * (C + 255.0)) / (255.0 * (259.0 - C));
            const gammaFactor = 1.0 / gamma;

            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                r = Math.max(0, Math.min(255, r + brightness));
                g = Math.max(0, Math.min(255, g + brightness));
                b = Math.max(0, Math.min(255, b + brightness));

                r = (r - 128) * contrastFactor + 128;
                g = (g - 128) * contrastFactor + 128;
                b = (b - 128) * contrastFactor + 128;

                r = 255 * Math.pow(r / 255, gammaFactor);
                g = 255 * Math.pow(g / 255, gammaFactor);
                b = 255 * Math.pow(b / 255, gammaFactor);

                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b));
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function resetFilterSliders() {
            document.getElementById('brightness-slider').value = 0;
            document.getElementById('contrast-slider').value = 0;
            document.getElementById('gamma-slider').value = 100;
            document.getElementById('brightness-val').textContent = 0;
            document.getElementById('contrast-val').textContent = 0;
            document.getElementById('gamma-val').textContent = 1.00;
            if (originalImageData) {
                 ctx.putImageData(originalImageData, 0, 0);
            }
        }

        /**
         * Setup filter listeners for instant preview (Existing)
         */
        function setupFilterListeners() {
            const brightnessSlider = document.getElementById('brightness-slider');
            const contrastSlider = document.getElementById('contrast-slider');
            const gammaSlider = document.getElementById('gamma-slider');

            const updateFilters = () => {
                const b = parseInt(brightnessSlider.value);
                const c = parseInt(contrastSlider.value);
                const g = parseFloat(gammaSlider.value) / 100;

                document.getElementById('brightness-val').textContent = b;
                document.getElementById('contrast-val').textContent = c;
                document.getElementById('gamma-val').textContent = g.toFixed(2);

                if (currentImage) {
                    applyFilter(b, c, g);
                }
            };

            brightnessSlider.addEventListener('input', updateFilters);
            contrastSlider.addEventListener('input', updateFilters);
            gammaSlider.addEventListener('input', updateFilters);

            // Listener for the explicit Save Adjustments button
            document.getElementById('apply-filter-btn').addEventListener('click', () => {
                if (currentImage) {
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    saveState();
                    showUINotification('Artistic adjustments saved to history.', 'success');
                } else {
                    showUINotification('Load an image before applying filters.', 'warning');
                }
            });
        }

        /**
         * Modal Logic (NEW)
         */
        function setupModalListeners() {
            const modal = document.getElementById('prompt-guide-modal');
            const showBtn = document.getElementById('show-guide-btn');
            const closeBtn = document.getElementById('close-guide-btn');

            showBtn.addEventListener('click', () => {
                modal.classList.remove('hidden');
                document.body.style.overflow = 'hidden'; // Prevent scrolling background
                feather.replace(); // Re-render icons inside modal
            });

            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
                document.body.style.overflow = '';
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.add('hidden');
                    document.body.style.overflow = '';
                }
            });
        }


        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Setup canvases and UI elements
            canvas = document.getElementById('editor-canvas');
            ctx = canvas.getContext('2d');
            maskCanvas = document.getElementById('mask-canvas');
            maskCtx = maskCanvas.getContext('2d');
            canvasContainer = document.getElementById('canvas-container');
            
            // Initialize sliders and controls
            creativitySlider = document.getElementById('creativity-slider');
            strengthSlider = document.getElementById('strength-slider');
            creativityVal = document.getElementById('creativity-val');
            strengthVal = document.getElementById('strength-val');
            strictFidelityMode = document.getElementById('strict-fidelity-mode');
            pureGenerationMode = document.getElementById('pure-generation-mode');
            const brushSizeSlider = document.getElementById('brush-size-slider');
            const brushSizeVal = document.getElementById('brush-size-val');

            // Slider value display updates
            creativitySlider.addEventListener('input', () => creativityVal.textContent = parseFloat(creativitySlider.value).toFixed(2));
            strengthSlider.addEventListener('input', () => strengthVal.textContent = parseFloat(strengthSlider.value).toFixed(2));
            brushSizeSlider.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                brushSizeVal.textContent = brushSize;
            });
            
            // History navigation
            document.getElementById('undo-btn').addEventListener('click', () => {
                if (historyPointer > 0) loadState(historyPointer - 1);
            });
            document.getElementById('redo-btn').addEventListener('click', () => {
                if (historyPointer < historyStack.length - 1) loadState(historyPointer + 1);
            });

            // Inpainting setup
            document.getElementById('toggle-mask-btn').addEventListener('click', toggleInpaintingMode);
            document.getElementById('clear-mask-btn').addEventListener('click', clearMask);
            
            // Mask Drawing Events (using maskCanvas)
            maskCanvas.addEventListener('mousedown', startDrawing);
            maskCanvas.addEventListener('mousemove', drawMask);
            maskCanvas.addEventListener('mouseup', stopDrawing);
            maskCanvas.addEventListener('mouseout', stopDrawing);
            
            maskCanvas.addEventListener('touchstart', startDrawing);
            maskCanvas.addEventListener('touchmove', drawMask);
            maskCanvas.addEventListener('touchend', stopDrawing);

            // Initialize filter listeners
            setupFilterListeners();
            
            // Initialize Modal Listeners (NEW)
            setupModalListeners();

            // Initialization logic
            function initializeCreativeCanvas() {
                // Initialize default canvas to max stable size for pure generation start
                canvas.width = MAX_DIMENSION; 
                canvas.height = MAX_DIMENSION;
                maskCanvas.width = MAX_DIMENSION; // Match mask size
                maskCanvas.height = MAX_DIMENSION;
                
                // FIX: Set dimensions for the stacking parent on initialization
                const canvasStack = document.getElementById('canvas-stack');
                canvasStack.style.width = MAX_DIMENSION + 'px';
                canvasStack.style.height = MAX_DIMENSION + 'px';

                // We no longer set a fixed height on the canvas container
                // canvasContainer.style.height = (MAX_DIMENSION + 20) + 'px';
                drawPlaceholder();
            }

            function drawPlaceholder() {
                ctx.fillStyle = '#111827';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#8b5cf6';
                ctx.font = 'bold 18px "Inter", Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Welcome to Creative Digital Alchemy', canvas.width / 2, canvas.height / 2 - 20);
                ctx.fillStyle = '#9ca3af';
                ctx.font = '14px "Inter", Arial';
                ctx.fillText('Import content or use Pure Generation Mode', canvas.width / 2, canvas.height / 2 + 20);
                document.getElementById('export-btn').disabled = true;
                document.getElementById('apply-filter-btn').disabled = true;
            }

            // File Import Logic
            document.getElementById('import-btn').addEventListener('click', () => {
                document.getElementById('file-input').click();
            });

            document.getElementById('file-input').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        loadImageSourceToCanvas(e.target.result, () => showUINotification('Image imported for deep transformation.', 'success'));
                    };
                    reader.readAsDataURL(file);
                } else if (file) {
                    showUINotification('Please select a valid image file.', 'error');
                }
                event.target.value = '';
            });

            // Export Logic
            document.getElementById('export-btn').addEventListener('click', () => {
                if (currentImage) {
                    const dataURL = canvas.toDataURL(IMAGE_MIME_TYPE);
                    const a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'creative-alchemy-image.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    showUINotification('Art exported successfully!', 'success');
                } else {
                    showUINotification('Nothing to export!', 'error');
                }
            });


          // Main Diffusion/Generation Handler (SECURE VERSION)
document.getElementById('apply-diffusion-btn').addEventListener('click', async () => {
  // [Your existing validation code remains the same...]

  showLoading(isPureMode ? 'Creating pure artistic content...' : (isMaskActive ? 'Applying Inpainting Transformation...' : 'Transforming your creative vision...'));

  try {
    const prompt = document.getElementById('diffusion-prompt').value;
    const negative = document.getElementById('negative-prompt').value;
    const creativity = parseFloat(creativitySlider.value).toFixed(2);
    const strength = parseFloat(strengthSlider.value).toFixed(2);
    
    // Prepare request payload
    const payload = {
      prompt,
      negative,
      creativity,
      strength
    };

    // Add image data if not pure generation
    if (!isPureMode && currentImage) {
      payload.image = canvas.toDataURL().split(',')[1];
      if (maskDrawn) {
        payload.mask = getBinaryMaskBase64();
      }
    }

    // Call YOUR backend (NOT Google directly)
    const response = await fetch(getCreativeApiUrl(), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    
    // Process the response
    if (result.image) {
      await new Promise(resolve => loadImageSourceToCanvas(result.image, resolve));
      showUINotification('Advanced creation complete! ✨', 'success');
      
      if (isInpaintingMode) {
        toggleInpaintingMode();
      }
    } else {
      throw new Error("No image data returned from server");
    }

  } catch (error) {
    console.error('Generation Error:', error);
    showUINotification(error.message, 'error');
  } finally {
    hideLoading();
  }
});
            // Enhanced random seed generation
            document.getElementById('random-seed-btn').addEventListener('click', () => {
                const randomSeed = Math.floor(Math.random() * 4294967295);
                document.getElementById('seed-input').value = randomSeed;
                showUINotification(`Seed set to ${randomSeed} for consistent results.`, 'warning');
            });

            // Initialize the application
            initializeCreativeCanvas();
            feather.replace();
            showUINotification('Model configured to use gemini-2.5-flash-image-preview.', 'success');
        });
    </script>
</body>
</html>
